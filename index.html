<!DOCTYPE html>
<meta charset="utf-8">
<style>
  body { margin: 0; background: #000; }
  svg { width: 100vw; height: 100vh; display: block; }
  line { stroke: #aaa; }
  circle { stroke: #fff; stroke-width: 1.5px; }
  text { font: 10px sans-serif; fill: #fff; pointer-events: none; }
</style>
<body>
<svg></svg>
<script src="https://d3js.org/d3.v7.min.js"></script>
<script>
const apiKey = "patB8cm7VUd15sLk8.e54309b459eb1ebf40e9515d4e0a840b84dc7eba0421a5ad79c3b67f1899c65b";
const baseId = "appbvoK6uB9kPATTN";
const tableName = "Pairings";
const url = `https://api.airtable.com/v0/${baseId}/${tableName}?pageSize=100`;

async function fetchData() {
  const res = await fetch(url, {
    headers: { Authorization: `Bearer ${apiKey}` }
  });
  const data = await res.json();
  return data.records.map(r => r.fields);
}

function generateEdges(data) {
  const grouped = {};
  data.forEach(row => {
    const key = `${row.Robin}__${row.Group}`;
    if (!grouped[key]) grouped[key] = [];
    grouped[key].push(row.Name);
  });

  const links = [];
  const nodesSet = new Set();
  Object.values(grouped).forEach(group => {
    for (let i = 0; i < group.length; i++) {
      for (let j = i + 1; j < group.length; j++) {
        links.push({ source: group[i], target: group[j] });
        nodesSet.add(group[i]);
        nodesSet.add(group[j]);
      }
    }
  });

  return {
    nodes: Array.from(nodesSet).map(id => ({ id })),
    links
  };
}

function renderGraph(graph) {
  const svg = d3.select("svg"),
        width = window.innerWidth,
        height = window.innerHeight;

  const simulation = d3.forceSimulation(graph.nodes)
    .force("link", d3.forceLink(graph.links).id(d => d.id).distance(100))
    .force("charge", d3.forceManyBody().strength(-200))
    .force("center", d3.forceCenter(width / 2, height / 2));

  const link = svg.append("g")
    .selectAll("line")
    .data(graph.links)
    .enter().append("line")
    .attr("stroke-width", 1);

  const node = svg.append("g")
    .selectAll("circle")
    .data(graph.nodes)
    .enter().append("circle")
    .attr("r", 6)
    .call(drag(simulation));

  const label = svg.append("g")
    .selectAll("text")
    .data(graph.nodes)
    .enter().append("text")
    .text(d => d.id)
    .attr("font-size", 10);

  simulation.on("tick", () => {
    link
      .attr("x1", d => d.source.x)
      .attr("y1", d => d.source.y)
      .attr("x2", d => d.target.x)
      .attr("y2", d => d.target.y);

    node
      .attr("cx", d => d.x)
      .attr("cy", d => d.y);

    label
      .attr("x", d => d.x + 8)
      .attr("y", d => d.y + 4);
  });

  function drag(simulation) {
    return d3.drag()
      .on("start", (event, d) => {
        if (!event.active) simulation.alphaTarget(0.3).restart();
        d.fx = d.x;
        d.fy = d.y;
      })
      .on("drag", (event, d) => {
        d.fx = event.x;
        d.fy = event.y;
      })
      .on("end", (event, d) => {
        if (!event.active) simulation.alphaTarget(0);
        d.fx = null;
        d.fy = null;
      });
  }
}

fetchData().then(data => {
  const graph = generateEdges(data);
  renderGraph(graph);
});
</script>
</body>
